set.seed(1234)
data("EuStockMarkets")
analyze_arch2 <- function(index_series, label) {
log_returns <- diff(log(index_series))
drift <- mean(log_returns)
par(mfrow = c(1, 2))
acf(log_returns, main = paste(label, "log returns ACF"))
acf(log_returns^2, main = paste(label, "squared returns ACF"))
fit <- arima(log_returns^2, order = c(2, 0, 0))
phi <- fit$coef[1:2]
a0 <- fit$coef[3]
n <- length(index_series)
y <- numeric(n)
y[1:2] <- log_returns[1:2]
z <- rnorm(n)
for (i in 3:n) {
s <- sqrt(a0 + phi[1] * y[i - 1]^2 + phi[2] * y[i - 2]^2)
y[i] <- s * z[i]
}
y <- y + drift
y <- c(log(index_series[1]), y)
sim_index <- exp(cumsum(y))
par(mfrow = c(1, 2))
ts.plot(index_series, main = paste(label, "Index"), ylab = "Index")
ts.plot(sim_index, main = paste(label, "Simulated Index"), ylab = "Index")
invisible(list(
log_returns = log_returns,
drift = drift,
fit = fit,
sim_index = sim_index
))
}
dax <- EuStockMarkets[, "DAX"]
dax_out <- analyze_arch2(dax, "DAX")
cac <- EuStockMarkets[, "CAC"]
cac_out <- analyze_arch2(cac, "CAC")
ftse <- EuStockMarkets[, "FTSE"]
n <- length(ftse)
log_returns <- diff(log(ftse))
log_returns_q <- c(
min(log_returns) * 1.01,
quantile(log_returns, (1:9) / 10),
max(log_returns) * 1.01
)
log_returns_cut <- cut(log_returns, log_returns_q)
levels(log_returns_cut) <- 1:10
ts.plot(ftse, main = "FTSE Index", ylab = "Index Level", xlab = "Time")
ftse[995:1005]
ftse[n]
P <- matrix(c(1:4, 4:1, 1, 4, 4, 1, 4, 1, 4, 1), nrow = 4, byrow = TRUE) / 10
PE <- matrix(
c(1:10, 10:1, rep(5.5, 10), c(rep(1, 5), rep(10, 5))),
nrow = 4,
byrow = TRUE
) / 55
library(HMM)
states <- 1:4
symbols <- 1:10
hmm0 <- initHMM(
States = states,
Symbols = symbols,
startProbs = rep(1 / 4, 4),
transProbs = P,
emissionProbs = PE
)
n_training <- 1000
hmm_fit <- baumWelch(hmm0, observation = log_returns_cut[1:n_training])
N <- 1000
n_testing <- n - n_training
index_859 <- numeric(N)
for (i in 1:N) {
index <- as.numeric(simHMM(hmm_fit$hmm, n_testing)$observation)
index_859[i] <- exp(
cumsum(
c(
log(ftse[n_training]),
runif(n_testing, min = log_returns_q[index], max = log_returns_q[index + 1])
)
)
)[n_testing]
}
hist(
index_859,
breaks = 30,
main = "Simulated Estimates of FTSE[1859]",
xlab = "Simulated FTSE Ending Value",
col = "lightgray",
border = "white"
)
actual_val <- ftse[n]
rug(actual_val, col = "red", lwd = 3)
abline(v = actual_val, col = "red", lwd = 2)
actual_val
n_training <- 1829
n_testing <- 1859 - 1829
index_option <- numeric(N)
for (i in 1:N) {
index <- as.numeric(simHMM(hmm_fit$hmm, n_testing)$observation)
sim_log_ret <- runif(
n_testing,
min = log_returns_q[index],
max = log_returns_q[index + 1]
)
sim_path <- exp(cumsum(c(log(ftse[n_training]), sim_log_ret)))
index_option[i] <- sim_path[n_testing + 1]
}
K <- 5000
option_price <- mean((index_option - K) * (index_option > K))
option_price
set.seed(1234)
set.seed(1234)
states <- 0:10
inflow_probs <- c(0.3, 0.1, 0.3, 0.2, 0.1)
names(inflow_probs) <- 0:4
P_res <- matrix(0, nrow = 11, ncol = 11, dimnames = list(states, states))
for (i in states) {
base <- max(0, i - 2)
for (k in 0:4) {
j <- min(10, base + k)
P_res[i + 1, j + 1] <- P_res[i + 1, j + 1] + inflow_probs[as.character(k)]
}
}
P_res
A <- t(P_res) - diag(11)
A <- rbind(A, rep(1, 11))
RHS <- c(rep(0, 11), 1)
pi_res <- qr.solve(A, RHS)
pi_res
cost_vec <- ifelse(states == 0, 12, ifelse(states == 1, 7, 2))
long_run_cost <- sum(cost_vec * pi_res)
long_run_cost
n_weeks <- 100000
X <- numeric(n_weeks)
X[1] <- 1
for (t in 1:(n_weeks - 1)) {
X[t + 1] <- sample(states, size = 1, prob = P_res[X[t] + 1, ])
}
weekly_costs <- cost_vec[X + 1]
annual_costs <- sapply(seq(1, n_weeks - 51, by = 52), function(k) {
sum(weekly_costs[k:(k + 51)])
})
prob_annual_cost_gt_250 <- mean(annual_costs > 250)
prob_annual_cost_gt_250
dice_prob <- c(0, 0, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1) / 36
P_board <- matrix(0, 40, 40)
for (i in 1:40) {
for (roll in 2:12) {
prob <- dice_prob[roll]
j <- (i + roll - 1) %% 40 + 1
if (j == 31) j <- 11
if (i == 11) {
j <- (11 + roll - 1) %% 40 + 1
if (j == 31) j <- 11
}
P_board[i, j] <- P_board[i, j] + prob
}
}
P_board
A <- t(P_board) - diag(40)
A <- rbind(A, rep(1, 40))
RHS <- c(rep(0, 40), 1)
PI <- qr.solve(A, RHS)
names(PI) <- 1:40
barplot(
PI,
names.arg = 1:40,
main = "Long-Run Steady-State Probabilities for Monopoly Board",
xlab = "Board Space",
ylab = "Steady-State Probability",
border = NA,
las = 2
)
sort(PI, decreasing = TRUE)[1:5]
PI["40"]
revenue_vec <- numeric(40)
revenue_vec[c(17, 19)] <- 950
revenue_vec[20] <- 1000
cost_vec <- numeric(40)
cost_vec[38] <- 1500
cost_vec[40] <- 2000
E_rev <- sum(revenue_vec * PI)
E_cost <- sum(cost_vec * PI)
profit <- E_rev - E_cost
E_rev
E_cost
profit
Var_rev <- sum(PI * revenue_vec^2) - E_rev^2
Var_cost <- sum(PI * cost_vec^2) - E_cost^2
Var_profit <- Var_rev + Var_cost
SD_profit <- sqrt(Var_profit)
Var_rev
Var_cost
Var_profit
SD_profit
revenue_vec2 <- numeric(40)
revenue_vec2[c(17, 19)] <- 950
revenue_vec2[20] <- 1000
revenue_vec2[22] <- 1050
revenue_vec2[24] <- 1050
revenue_vec2[25] <- 1100
cost_vec2 <- numeric(40)
cost_vec2[38] <- 1500
cost_vec2[40] <- 2000
cost_vec2[32] <- 1275
cost_vec2[33] <- 1275
cost_vec2[35] <- 1400
E_rev_2 <- sum(revenue_vec2 * PI)
E_cost_2 <- sum(cost_vec2 * PI)
profit_2 <- E_rev_2 - E_cost_2
Var_rev2 <- sum(PI * revenue_vec2^2) - E_rev_2^2
Var_cost2 <- sum(PI * cost_vec2^2) - E_cost_2^2
Var_profit2 <- Var_rev2 + Var_cost2
SD_profit2 <- sqrt(Var_profit2)
E_rev_2
E_cost_2
profit_2
Var_rev2
Var_cost2
Var_profit2
SD_profit2
next_state <- function(state, P) {
sample(1:40, size = 1, prob = P[state, ])
}
simulate_game <- function(P, rev_vec, cost_vec, cash0 = 5000) {
pos_me <- 1
pos_opp <- 1
cash_me <- cash0
cash_opp <- cash0
repeat {
pos_me <- next_state(pos_me, P)
cash_me <- cash_me + rev_vec[pos_opp] - cost_vec[pos_me]
if (cash_me <= 0) return(0)
pos_opp <- next_state(pos_opp, P)
cash_opp <- cash_opp + rev_vec[pos_me] - cost_vec[pos_opp]
if (cash_opp <= 0) return(1)
}
}
N <- 1000
wins <- numeric(N)
for (i in 1:N) {
wins[i] <- simulate_game(P_board, revenue_vec, cost_vec)
}
prob_win_a <- mean(wins)
prob_win_a
wins <- numeric(N)
for (i in 1:N) {
wins[i] <- simulate_game(P_board, revenue_vec2, cost_vec2)
}
prob_win_b <- mean(wins)
prob_win_b
dice_prob <- c(0, 0, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1) / 36
P_board <- matrix(0, 40, 40)
for (i in 1:40) {
for (roll in 2:12) {
prob <- dice_prob[roll]
j <- (i + roll - 1) %% 40 + 1
if (j == 31) j <- 11
if (i == 11) {
j <- (11 + roll - 1) %% 40 + 1
if (j == 31) j <- 11
}
P_board[i, j] <- P_board[i, j] + prob
}
}
heatmap(P_board)
A <- t(P_board) - diag(40)
A <- rbind(A, rep(1, 40))
RHS <- c(rep(0, 40), 1)
PI <- qr.solve(A, RHS)
names(PI) <- 1:40
barplot(
PI,
names.arg = 1:40,
main = "Long-Run Steady-State Probabilities for Monopoly Board",
xlab = "Board Space",
ylab = "Steady-State Probability",
border = NA,
las = 2
)
print(c("Example: Probability of landing on Space 40",PI["40"]))
print(c("Most visited spaces": sort(PI, decreasing = TRUE)[1:5]))
A <- t(P_board) - diag(40)
A <- rbind(A, rep(1, 40))
RHS <- c(rep(0, 40), 1)
PI <- qr.solve(A, RHS)
names(PI) <- 1:40
barplot(
PI,
names.arg = 1:40,
main = "Long-Run Steady-State Probabilities for Monopoly Board",
xlab = "Board Space",
ylab = "Steady-State Probability",
border = NA,
las = 2
)
print(c("Example: Probability of landing on Space 40",PI["40"]))
print(c("Most visited spaces:", sort(PI, decreasing = TRUE)[1:5]))
A <- t(P_board) - diag(40)
A <- rbind(A, rep(1, 40))
RHS <- c(rep(0, 40), 1)
PI <- qr.solve(A, RHS)
names(PI) <- 1:40
barplot(
PI,
names.arg = 1:40,
main = "Long-Run Steady-State Probabilities for Monopoly Board",
xlab = "Board Space",
ylab = "Steady-State Probability",
border = NA,
las = 2
)
print(c("Example: Probability of landing on Space 40\n",PI["40"]))
print(c("Most visited spaces:\n", sort(PI, decreasing = TRUE)[1:5]))
A <- t(P_board) - diag(40)
A <- rbind(A, rep(1, 40))
RHS <- c(rep(0, 40), 1)
PI <- qr.solve(A, RHS)
names(PI) <- 1:40
barplot(
PI,
names.arg = 1:40,
main = "Long-Run Steady-State Probabilities for Monopoly Board",
xlab = "Board Space",
ylab = "Steady-State Probability",
border = NA,
las = 2
)
print("Example: Probability of landing on Space 40")
PI["40"]
print("Most visited spaces:")
sort(PI, decreasing = TRUE)[1:5]
